<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playground - Browser Games Collection</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .game-container {
            transition: all 0.3s ease;
        }
        .game-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
        }
        #snakeCanvas, #tetrisCanvas, #breakoutCanvas, #ticTacToeBoard, #memoryGameBoard, #hangmanCanvas {
            background-color: #f3f4f6;
            border-radius: 0.5rem;
        }
        .cell {
            width: 60px;
            height: 60px;
        }
        @media (max-width: 640px) {
            .cell {
                width: 50px;
                height: 50px;
            }
        }
        .memory-card {
            perspective: 1000px;
            width: 80px;
            height: 100px;
        }
        .memory-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .memory-card.flipped .memory-card-inner {
            transform: rotateY(180deg);
        }
        .memory-card-front, .memory-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        .memory-card-back {
            background-color: #4f46e5;
            color: white;
        }
        .memory-card-front {
            background-color: white;
            transform: rotateY(180deg);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <header class="bg-indigo-600 text-white shadow-lg">
        <div class="container mx-auto px-4 py-6">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <h1 class="text-3xl font-bold mb-4 md:mb-0">üéÆ Playground</h1>
                <p class="text-xl">A collection of self-made browser games</p>
            </div>
        </div>
    </header>

    <main class="container mx-auto px-4 py-8">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
            <!-- Snake Game -->
            <div class="game-container bg-white rounded-xl shadow-md overflow-hidden">
                <div class="p-6">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">üêç Snake Game</h2>
                    <canvas id="snakeCanvas" width="300" height="300" class="w-full border border-gray-200"></canvas>
                    <div class="mt-4 flex flex-col space-y-2">
                        <p class="text-gray-600">Score: <span id="snakeScore">0</span></p>
                        <div class="flex space-x-2">
                            <button onclick="startSnakeGame()" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition">Start</button>
                            <button onclick="pauseSnakeGame()" class="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition">Pause</button>
                            <button onclick="resetSnakeGame()" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition">Reset</button>
                        </div>
                        <p class="text-sm text-gray-500">Use arrow keys to control the snake</p>
                    </div>
                </div>
            </div>

            <!-- Tetris Game -->
            <div class="game-container bg-white rounded-xl shadow-md overflow-hidden">
                <div class="p-6">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">üßä Tetris</h2>
                    <canvas id="tetrisCanvas" width="300" height="500" class="w-full border border-gray-200"></canvas>
                    <div class="mt-4 flex flex-col space-y-2">
                        <p class="text-gray-600">Score: <span id="tetrisScore">0</span> | Level: <span id="tetrisLevel">1</span></p>
                        <div class="flex space-x-2">
                            <button onclick="startTetrisGame()" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition">Start</button>
                            <button onclick="pauseTetrisGame()" class="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition">Pause</button>
                            <button onclick="resetTetrisGame()" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition">Reset</button>
                        </div>
                        <p class="text-sm text-gray-500">Use arrow keys to move and rotate</p>
                    </div>
                </div>
            </div>

            <!-- Breakout Game -->
            <div class="game-container bg-white rounded-xl shadow-md overflow-hidden">
                <div class="p-6">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">üöÄ Breakout</h2>
                    <canvas id="breakoutCanvas" width="300" height="400" class="w-full border border-gray-200"></canvas>
                    <div class="mt-4 flex flex-col space-y-2">
                        <p class="text-gray-600">Score: <span id="breakoutScore">0</span> | Lives: <span id="breakoutLives">3</span></p>
                        <div class="flex space-x-2">
                            <button onclick="startBreakoutGame()" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition">Start</button>
                            <button onclick="pauseBreakoutGame()" class="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition">Pause</button>
                            <button onclick="resetBreakoutGame()" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition">Reset</button>
                        </div>
                        <p class="text-sm text-gray-500">Move mouse to control the paddle</p>
                    </div>
                </div>
            </div>

            <!-- Tic Tac Toe -->
            <div class="game-container bg-white rounded-xl shadow-md overflow-hidden">
                <div class="p-6">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">‚≠ï Tic Tac Toe</h2>
                    <div id="ticTacToeBoard" class="grid grid-cols-3 gap-2 bg-gray-200 p-2 rounded">
                        <!-- Cells will be generated by JavaScript -->
                    </div>
                    <div class="mt-4 flex flex-col space-y-2">
                        <p class="text-gray-600">Current Player: <span id="currentPlayer">X</span></p>
                        <p id="gameResult" class="font-bold text-green-600"></p>
                        <button onclick="resetTicTacToe()" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition">Reset Game</button>
                        <p class="text-sm text-gray-500">Click on cells to place X or O</p>
                    </div>
                </div>
            </div>

            <!-- Memory Game -->
            <div class="game-container bg-white rounded-xl shadow-md overflow-hidden">
                <div class="p-6">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">üß† Memory Game</h2>
                    <div id="memoryGameBoard" class="grid grid-cols-4 gap-2 p-2">
                        <!-- Cards will be generated by JavaScript -->
                    </div>
                    <div class="mt-4 flex flex-col space-y-2">
                        <p class="text-gray-600">Pairs Found: <span id="pairsFound">0</span>/8 | Attempts: <span id="attempts">0</span></p>
                        <button onclick="startMemoryGame()" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition">New Game</button>
                        <p class="text-sm text-gray-500">Find all matching pairs</p>
                    </div>
                </div>
            </div>

            <!-- Hangman Game -->
            <div class="game-container bg-white rounded-xl shadow-md overflow-hidden">
                <div class="p-6">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">üòµ Hangman</h2>
                    <canvas id="hangmanCanvas" width="300" height="200" class="w-full border border-gray-200 bg-white"></canvas>
                    <div class="mt-4" id="wordDisplay">
                        <!-- Word will be displayed here with blanks -->
                    </div>
                    <div class="mt-2 grid grid-cols-7 gap-2" id="keyboard">
                        <!-- Keyboard will be generated by JavaScript -->
                    </div>
                    <div class="mt-4 flex flex-col space-y-2">
                        <p class="text-gray-600">Lives: <span id="hangmanLives">6</span> | Category: <span id="category">Animals</span></p>
                        <div class="flex space-x-2">
                            <button onclick="startHangmanGame()" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition">New Game</button>
                            <button onclick="changeHangmanCategory()" class="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 transition">Change Category</button>
                        </div>
                        <p class="text-sm text-gray-500">Guess the word before the man is hanged!</p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white py-6">
        <div class="container mx-auto px-4 text-center">
            <p>Made with love by Navaid_ali</p>
            <p class="mt-2 text-gray-400">All games created with HTML, CSS and JavaScript</p>
        </div>
    </footer>

    <script>
        // ======================================
        // Snake Game Implementation
        // ======================================
        const snakeCanvas = document.getElementById('snakeCanvas');
        const snakeCtx = snakeCanvas.getContext('2d');
        const snakeScoreDisplay = document.getElementById('snakeScore');
        let snake = [];
        let food = {};
        let dx = 20;
        let dy = 0;
        let snakeScore = 0;
        let gameInterval;
        let isPaused = false;

        function startSnakeGame() {
            if (gameInterval) clearInterval(gameInterval);
            snake = [{x: 160, y: 160}];
            food = generateFood();
            dx = 20;
            dy = 0;
            snakeScore = 0;
            snakeScoreDisplay.textContent = snakeScore;
            gameInterval = setInterval(gameLoop, 200);
            isPaused = false;
        }

        function pauseSnakeGame() {
            isPaused = !isPaused;
        }

        function resetSnakeGame() {
            clearInterval(gameInterval);
            snakeCtx.clearRect(0, 0, snakeCanvas.width, snakeCanvas.height);
            snakeScoreDisplay.textContent = '0';
            document.getElementById('snakeScore').textContent = '0';
        }

        function generateFood() {
            const foodX = Math.floor(Math.random() * (snakeCanvas.width / 20)) * 20;
            const foodY = Math.floor(Math.random() * (snakeCanvas.height / 20)) * 20;
            
            // Make sure food doesn't spawn on snake
            for (let segment of snake) {
                if (segment.x === foodX && segment.y === foodY) {
                    return generateFood();
                }
            }
            
            return {x: foodX, y: foodY};
        }

        function gameLoop() {
            if (isPaused) return;
            
            moveSnake();
            
            // Check collision with walls
            if (snake[0].x < 0 || snake[0].x >= snakeCanvas.width || 
                snake[0].y < 0 || snake[0].y >= snakeCanvas.height) {
                clearInterval(gameInterval);
                alert('Game Over! Your score: ' + snakeScore);
                return;
            }
            
            // Check collision with self
            for (let i = 1; i < snake.length; i++) {
                if (snake[0].x === snake[i].x && snake[0].y === snake[i].y) {
                    clearInterval(gameInterval);
                    alert('Game Over! Your score: ' + snakeScore);
                    return;
                }
            }
            
            // Check if snake ate food
            if (snake[0].x === food.x && snake[0].y === food.y) {
                snakeScore += 10;
                snakeScoreDisplay.textContent = snakeScore;
                food = generateFood();
            } else {
                snake.pop(); // Remove tail if no food was eaten
            }
            
            drawSnakeGame();
        }

        function moveSnake() {
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            snake.unshift(head);
        }

        function drawSnakeGame() {
            snakeCtx.clearRect(0, 0, snakeCanvas.width, snakeCanvas.height);
            
            // Draw snake
            snakeCtx.fillStyle = '#4f46e5';
            for (let i = 0; i < snake.length; i++) {
                snakeCtx.fillRect(snake[i].x, snake[i].y, 20, 20);
                snakeCtx.strokeStyle = 'white';
                snakeCtx.strokeRect(snake[i].x, snake[i].y, 20, 20);
            }
            
            // Draw food
            snakeCtx.fillStyle = '#ef4444';
            snakeCtx.fillRect(food.x, food.y, 20, 20);
        }

        document.addEventListener('keydown', function(e) {
            // Left arrow
            if (e.key === 'ArrowLeft' && dx !== 20) {
                dx = -20;
                dy = 0;
            }
            // Right arrow
            else if (e.key === 'ArrowRight' && dx !== -20) {
                dx = 20;
                dy = 0;
            }
            // Up arrow
            else if (e.key === 'ArrowUp' && dy !== 20) {
                dx = 0;
                dy = -20;
            }
            // Down arrow
            else if (e.key === 'ArrowDown' && dy !== -20) {
                dx = 0;
                dy = 20;
            }
        });

        // Initialize snake canvas
        drawSnakeGame();

        // ======================================
        // Tetris Game Implementation
        // ======================================
        const tetrisCanvas = document.getElementById('tetrisCanvas');
        const tetrisCtx = tetrisCanvas.getContext('2d');
        const tetrisScoreDisplay = document.getElementById('tetrisScore');
        const tetrisLevelDisplay = document.getElementById('tetrisLevel');
        const tetrisGrid = 30;
        const tetrisCols = tetrisCanvas.width / tetrisGrid;
        const tetrisRows = tetrisCanvas.height / tetrisGrid;
        let tetrisScore = 0;
        let tetrisLevel = 1;
        let tetrisBoard = [];
        let tetrisPiece = null;
        let tetrisInterval;
        let tetrisPaused = false;

        // Tetris pieces
        const tetrisShapes = [
            [ [1, 1, 1, 1] ], // I
            [ [1, 1], [1, 1] ], // O
            [ [1, 1, 1], [0, 1, 0] ], // T
            [ [1, 1, 1], [1, 0, 0] ], // L
            [ [1, 1, 1], [0, 0, 1] ], // J
            [ [0, 1, 1], [1, 1, 0] ], // S
            [ [1, 1, 0], [0, 1, 1] ]  // Z
        ];

        // Colors for each piece
        const tetrisColors = [
            '#00f0f0', // I - Cyan
            '#f0f000', // O - Yellow
            '#a000f0', // T - Purple
            '#f0a000', // L - Orange
            '#0000f0', // J - Blue
            '#00f000', // S - Green
            '#f00000'  // Z - Red
        ];

        function startTetrisGame() {
            if (tetrisInterval) clearInterval(tetrisInterval);
            tetrisBoard = createBoard();
            tetrisScore = 0;
            tetrisLevel = 1;
            tetrisScoreDisplay.textContent = tetrisScore;
            tetrisLevelDisplay.textContent = tetrisLevel;
            tetrisPiece = getNextPiece();
            tetrisInterval = setInterval(dropPiece, 1000);
            tetrisPaused = false;
            drawTetrisGame();
        }

        function pauseTetrisGame() {
            tetrisPaused = !tetrisPaused;
        }

        function resetTetrisGame() {
            clearInterval(tetrisInterval);
            tetrisCtx.clearRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);
            tetrisScoreDisplay.textContent = '0';
            tetrisLevelDisplay.textContent = '1';
        }

        function createBoard() {
            return Array(tetrisRows).fill().map(() => Array(tetrisCols).fill(0));
        }

        function getNextPiece() {
            const shapeIdx = Math.floor(Math.random() * tetrisShapes.length);
            const shape = tetrisShapes[shapeIdx];
            const color = tetrisColors[shapeIdx];
            
            // Starting position
            const piece = {
                x: Math.floor(tetrisCols / 2) - Math.floor(shape[0].length / 2),
                y: 0,
                shape: shape,
                color: color
            };
            
            // If starting position is invalid, game over
            if (checkCollision(piece)) {
                clearInterval(tetrisInterval);
                alert('Game Over! Your score: ' + tetrisScore);
                return null;
            }
            
            return piece;
        }

        function checkCollision(piece) {
            for (let r = 0; r < piece.shape.length; r++) {
                for (let c = 0; c < piece.shape[r].length; c++) {
                    if (!piece.shape[r][c]) continue;
                    
                    // Calculate new position
                    const newX = piece.x + c;
                    const newY = piece.y + r;
                    
                    // Check if out of bounds
                    if (newX < 0 || newX >= tetrisCols || newY >= tetrisRows) {
                        return true;
                    }
                    
                    // Don't allow moving up
                    if (newY < 0) {
                        continue;
                    }
                    
                    // Check if collides with existing piece
                    if (tetrisBoard[newY][newX]) {
                        return true;
                    }
                }
            }
            return false;
        }

        function dropPiece() {
            if (tetrisPaused) return;
            
            if (!tetrisPiece) return;
            
            // Try to move down
            tetrisPiece.y++;
            
            // If collision, lock the piece
            if (checkCollision(tetrisPiece)) {
                tetrisPiece.y--;
                lockPiece();
                tetrisPiece = getNextPiece();
                clearLines();
            }
            
            drawTetrisGame();
        }

        function lockPiece() {
            tetrisPiece.shape.forEach((row, r) => {
                row.forEach((cell, c) => {
                    if (cell) {
                        tetrisBoard[tetrisPiece.y + r][tetrisPiece.x + c] = tetrisPiece.color;
                    }
                });
            });
        }

        function clearLines() {
            let linesCleared = 0;
            
            for (let r = tetrisRows - 1; r >= 0; r--) {
                // Check if line is full
                if (tetrisBoard[r].every(cell => cell)) {
                    linesCleared++;
                    
                    // Remove the line
                    tetrisBoard.splice(r, 1);
                    // Add new empty line at top
                    tetrisBoard.unshift(Array(tetrisCols).fill(0));
                }
            }
            
            if (linesCleared > 0) {
                // Update score (basic scoring system)
                tetrisScore += linesCleared * 100 * tetrisLevel;
                tetrisScoreDisplay.textContent = tetrisScore;
                
                // Update level every 5 lines cleared
                if (Math.floor(tetrisScore / 500) + 1 > tetrisLevel) {
                    tetrisLevel = Math.floor(tetrisScore / 500) + 1;
                    tetrisLevelDisplay.textContent = tetrisLevel;
                    
                    // Increase speed
                    clearInterval(tetrisInterval);
                    tetrisInterval = setInterval(dropPiece, 1000 / tetrisLevel);
                }
            }
        }

        function rotatePiece() {
            if (!tetrisPiece) return;
            
            const originalShape = tetrisPiece.shape;
            
            // Transpose matrix
            const rows = tetrisPiece.shape.length;
            const cols = tetrisPiece.shape[0].length;
            const newShape = Array(cols).fill().map(() => Array(rows).fill(0));
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    newShape[c][rows - 1 - r] = tetrisPiece.shape[r][c];
                }
            }
            
            // Try new rotation
            tetrisPiece.shape = newShape;
            
            // If rotation causes collision, revert
            if (checkCollision(tetrisPiece)) {
                tetrisPiece.shape = originalShape;
            }
        }

        function drawTetrisGame() {
            tetrisCtx.clearRect(0, 0, tetrisCanvas.width, tetrisCanvas.height);
            
            // Draw locked pieces
            tetrisBoard.forEach((row, r) => {
                row.forEach((cell, c) => {
                    if (cell) {
                        tetrisCtx.fillStyle = cell;
                        tetrisCtx.fillRect(c * tetrisGrid, r * tetrisGrid, tetrisGrid, tetrisGrid);
                        tetrisCtx.strokeStyle = '#000';
                        tetrisCtx.strokeRect(c * tetrisGrid, r * tetrisGrid, tetrisGrid, tetrisGrid);
                    }
                });
            });
            
            // Draw current piece
            if (tetrisPiece) {
                tetrisPiece.shape.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            tetrisCtx.fillStyle = tetrisPiece.color;
                            tetrisCtx.fillRect(
                                (tetrisPiece.x + c) * tetrisGrid,
                                (tetrisPiece.y + r) * tetrisGrid,
                                tetrisGrid, 
                                tetrisGrid
                            );
                            tetrisCtx.strokeStyle = '#000';
                            tetrisCtx.strokeRect(
                                (tetrisPiece.x + c) * tetrisGrid,
                                (tetrisPiece.y + r) * tetrisGrid,
                                tetrisGrid, 
                                tetrisGrid
                            );
                        }
                    });
                });
            }
            
            // Draw grid
            tetrisCtx.strokeStyle = '#e5e7eb';
            for (let r = 0; r < tetrisRows; r++) {
                for (let c = 0; c < tetrisCols; c++) {
                    tetrisCtx.strokeRect(c * tetrisGrid, r * tetrisGrid, tetrisGrid, tetrisGrid);
                }
            }
        }

        document.addEventListener('keydown', function(e) {
            if (tetrisPaused || !tetrisPiece) return;
            
            if (e.key === 'ArrowLeft') {
                tetrisPiece.x--;
                if (checkCollision(tetrisPiece)) tetrisPiece.x++;
            }
            else if (e.key === 'ArrowRight') {
                tetrisPiece.x++;
                if (checkCollision(tetrisPiece)) tetrisPiece.x--;
            }
            else if (e.key === 'ArrowDown') {
                tetrisPiece.y++;
                if (checkCollision(tetrisPiece)) {
                    tetrisPiece.y--;
                    lockPiece();
                    tetrisPiece = getNextPiece();
                    clearLines();
                }
            }
            else if (e.key === 'ArrowUp') {
                rotatePiece();
            }
            else if (e.key === ' ') { // Space for hard drop
                while (!checkCollision(tetrisPiece)) {
                    tetrisPiece.y++;
                }
                tetrisPiece.y--;
                lockPiece();
                tetrisPiece = getNextPiece();
                clearLines();
            }
            
            drawTetrisGame();
        });

        // Initialize tetris canvas
        drawTetrisGame();

        // ======================================
        // Breakout Game Implementation
        // ======================================
        const breakoutCanvas = document.getElementById('breakoutCanvas');
        const breakoutCtx = breakoutCanvas.getContext('2d');
        const breakoutScoreDisplay = document.getElementById('breakoutScore');
        const breakoutLivesDisplay = document.getElementById('breakoutLives');
        let breakoutScore = 0;
        let breakoutLives = 3;
        let breakoutPaddleWidth = 75;
        let breakoutPaddleHeight = 15;
        let breakoutPaddleX = (breakoutCanvas.width - breakoutPaddleWidth) / 2;
        let breakoutBallRadius = 10;
        let breakoutBallX = breakoutCanvas.width / 2;
        let breakoutBallY = breakoutCanvas.height - 30;
        let breakoutBallSpeedX = 4;
        let breakoutBallSpeedY = -4;
        let breakoutRightPressed = false;
        let breakoutLeftPressed = false;
        let breakoutGameInterval;
        let breakoutPaused = false;

        // Bricks
        const breakoutBrickRowCount = 5;
        const breakoutBrickColumnCount = 9;
        const breakoutBrickWidth = 75;
        const breakoutBrickHeight = 20;
        const breakoutBrickPadding = 10;
        const breakoutBrickOffsetTop = 30;
        const breakoutBrickOffsetLeft = 30;
        let breakoutBricks = [];

        function initBreakoutBricks() {
            breakoutBricks = [];
            for (let c = 0; c < breakoutBrickColumnCount; c++) {
                breakoutBricks[c] = [];
                for (let r = 0; r < breakoutBrickRowCount; r++) {
                    breakoutBricks[c][r] = { x: 0, y: 0, status: 1, color: getRandomColor() };
                }
            }
        }

        function getRandomColor() {
            const colors = ['#FF5252', '#FF4081', '#E040FB', '#7C4DFF', '#536DFE', '#448AFF', '#40C4FF', '#18FFFF', '#64FFDA', '#69F0AE', '#B2FF59', '#EEFF41', '#FFFF00', '#FFD740', '#FFAB40', '#FF6E40'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function startBreakoutGame() {
            if (breakoutGameInterval) clearInterval(breakoutGameInterval);
            
            breakoutScore = 0;
            breakoutLives = 3;
            breakoutPaddleX = (breakoutCanvas.width - breakoutPaddleWidth) / 2;
            breakoutBallX = breakoutCanvas.width / 2;
            breakoutBallY = breakoutCanvas.height - 30;
            breakoutBallSpeedX = 4;
            breakoutBallSpeedY = -4;
            
            initBreakoutBricks();
            breakoutScoreDisplay.textContent = breakoutScore;
            breakoutLivesDisplay.textContent = breakoutLives;
            
            breakoutGameInterval = setInterval(drawBreakoutGame, 10);
            breakoutPaused = false;
        }

        function pauseBreakoutGame() {
            breakoutPaused = !breakoutPaused;
        }

        function resetBreakoutGame() {
            clearInterval(breakoutGameInterval);
            breakoutCtx.clearRect(0, 0, breakoutCanvas.width, breakoutCanvas.height);
            breakoutScoreDisplay.textContent = '0';
            breakoutLivesDisplay.textContent = '3';
        }

        function drawBreakoutBricks() {
            for (let c = 0; c < breakoutBrickColumnCount; c++) {
                for (let r = 0; r < breakoutBrickRowCount; r++) {
                    if (breakoutBricks[c][r].status === 1) {
                        const brickX = c * (breakoutBrickWidth + breakoutBrickPadding) + breakoutBrickOffsetLeft;
                        const brickY = r * (breakoutBrickHeight + breakoutBrickPadding) + breakoutBrickOffsetTop;
                        breakoutBricks[c][r].x = brickX;
                        breakoutBricks[c][r].y = brickY;
                        
                        breakoutCtx.beginPath();
                        breakoutCtx.rect(brickX, brickY, breakoutBrickWidth, breakoutBrickHeight);
                        breakoutCtx.fillStyle = breakoutBricks[c][r].color;
                        breakoutCtx.fill();
                        breakoutCtx.closePath();
                    }
                }
            }
        }

        function drawBreakoutPaddle() {
            breakoutCtx.beginPath();
            breakoutCtx.rect(breakoutPaddleX, breakoutCanvas.height - breakoutPaddleHeight, breakoutPaddleWidth, breakoutPaddleHeight);
            breakoutCtx.fillStyle = '#4f46e5';
            breakoutCtx.fill();
            breakoutCtx.closePath();
        }

        function drawBreakoutBall() {
            breakoutCtx.beginPath();
            breakoutCtx.arc(breakoutBallX, breakoutBallY, breakoutBallRadius, 0, Math.PI * 2);
            breakoutCtx.fillStyle = '#ef4444';
            breakoutCtx.fill();
            breakoutCtx.closePath();
        }

        function breakoutCollisionDetection() {
            for (let c = 0; c < breakoutBrickColumnCount; c++) {
                for (let r = 0; r < breakoutBrickRowCount; r++) {
                    const brick = breakoutBricks[c][r];
                    if (brick.status === 1) {
                        if (
                            breakoutBallX > brick.x && 
                            breakoutBallX < brick.x + breakoutBrickWidth && 
                            breakoutBallY > brick.y && 
                            breakoutBallY < brick.y + breakoutBrickHeight
                        ) {
                            breakoutBallSpeedY = -breakoutBallSpeedY;
                            brick.status = 0;
                            breakoutScore += 10;
                            breakoutScoreDisplay.textContent = breakoutScore;
                            
                            // Check if all bricks are cleared
                            if (breakoutScore === breakoutBrickRowCount * breakoutBrickColumnCount * 10) {
                                alert("YOU WIN, CONGRATULATIONS!");
                                clearInterval(breakoutGameInterval);
                            }
                        }
                    }
                }
            }
        }

        function drawBreakoutGame() {
            if (breakoutPaused) return;
            
            breakoutCtx.clearRect(0, 0, breakoutCanvas.width, breakoutCanvas.height);
            
            drawBreakoutBricks();
            drawBreakoutPaddle();
            drawBreakoutBall();
            breakoutCollisionDetection();
            
            // Wall collision
            if (breakoutBallX + breakoutBallSpeedX > breakoutCanvas.width - breakoutBallRadius || 
                breakoutBallX + breakoutBallSpeedX < breakoutBallRadius) {
                breakoutBallSpeedX = -breakoutBallSpeedX;
            }
            
            if (breakoutBallY + breakoutBallSpeedY < breakoutBallRadius) {
                breakoutBallSpeedY = -breakoutBallSpeedY;
            } 
            // Paddle collision
            else if (
                breakoutBallY + breakoutBallSpeedY > breakoutCanvas.height - breakoutBallRadius - breakoutPaddleHeight &&
                breakoutBallX > breakoutPaddleX && 
                breakoutBallX < breakoutPaddleX + breakoutPaddleWidth
            ) {
                // Calculate ball's angle based on where it hits the paddle
                const hitPosition = breakoutBallX - (breakoutPaddleX + breakoutPaddleWidth / 2);
                const normalizedHit = hitPosition / (breakoutPaddleWidth / 2);
                breakoutBallSpeedX = normalizedHit * 7; // Max horizontal speed
            
                breakoutBallSpeedY = -breakoutBallSpeedY;
            }
            // Bottom wall - lose a life
            else if (breakoutBallY + breakoutBallSpeedY > breakoutCanvas.height - breakoutBallRadius) {
                breakoutLives--;
                breakoutLivesDisplay.textContent = breakoutLives;
                
                if (breakoutLives === 0) {
                    alert("GAME OVER");
                    clearInterval(breakoutGameInterval);
                } else {
                    // Reset ball and paddle
                    breakoutBallX = breakoutCanvas.width / 2;
                    breakoutBallY = breakoutCanvas.height - 30;
                    breakoutBallSpeedX = 4;
                    breakoutBallSpeedY = -4;
                    breakoutPaddleX = (breakoutCanvas.width - breakoutPaddleWidth) / 2;
                }
            }
            
            breakoutBallX += breakoutBallSpeedX;
            breakoutBallY += breakoutBallSpeedY;
            
            // Paddle movement
            if (breakoutRightPressed && breakoutPaddleX < breakoutCanvas.width - breakoutPaddleWidth) {
                breakoutPaddleX += 7;
            } else if (breakoutLeftPressed && breakoutPaddleX > 0) {
                breakoutPaddleX -= 7;
            }
        }

        breakoutCanvas.addEventListener('mousemove', function(e) {
            const relativeX = e.clientX - breakoutCanvas.offsetLeft;
            if (relativeX > breakoutPaddleWidth / 2 && relativeX < breakoutCanvas.width - breakoutPaddleWidth / 2) {
                breakoutPaddleX = relativeX - breakoutPaddleWidth / 2;
            }
        });

        document.addEventListener('keydown', function(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                breakoutRightPressed = true;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                breakoutLeftPressed = true;
            }
        });

        document.addEventListener('keyup', function(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                breakoutRightPressed = false;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                breakoutLeftPressed = false;
            }
        });

        // Initialize breakout game
        initBreakoutBricks();
        drawBreakoutGame();

        // ======================================
        // Tic Tac Toe Game Implementation
        // ======================================
        const ticTacToeBoard = document.getElementById('ticTacToeBoard');
        const currentPlayerDisplay = document.getElementById('currentPlayer');
        const gameResultDisplay = document.getElementById('gameResult');
        let currentPlayer = 'X';
        let gameActive = true;
        let gameState = ['', '', '', '', '', '', '', '', ''];

        // Create the board
        function createTicTacToeBoard() {
            gameState = ['', '', '', '', '', '', '', '', ''];
            ticTacToeBoard.innerHTML = '';
            
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell bg-white rounded flex items-center justify-center text-4xl font-bold cursor-pointer transition hover:bg-gray-100';
                cell.setAttribute('data-index', i);
                cell.addEventListener('click', handleTicTacToeCellClick);
                ticTacToeBoard.appendChild(cell);
            }
            
            currentPlayer = 'X';
            gameActive = true;
            currentPlayerDisplay.textContent = currentPlayer;
            gameResultDisplay.textContent = '';
        }

        function handleTicTacToeCellClick(e) {
            const clickedCell = e.target;
            const clickedCellIndex = parseInt(clickedCell.getAttribute('data-index'));
            
            if (gameState[clickedCellIndex] !== '' || !gameActive) return;
            
            gameState[clickedCellIndex] = currentPlayer;
            clickedCell.textContent = currentPlayer;
            
            if (currentPlayer === 'X') {
                clickedCell.classList.add('text-indigo-600');
            } else {
                clickedCell.classList.add('text-red-600');
            }
            
            checkTicTacToeResult();
        }

        function checkTicTacToeResult() {
            const winConditions = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                [0, 4, 8], [2, 4, 6]             // diagonals
            ];
            
            let roundWon = false;
            
            for (let i = 0; i < winConditions.length; i++) {
                const [a, b, c] = winConditions[i];
                
                if (gameState[a] === '' || gameState[b] === '' || gameState[c] === '') continue;
                
                if (gameState[a] === gameState[b] && gameState[b] === gameState[c]) {
                    roundWon = true;
                    break;
                }
            }
            
            if (roundWon) {
                gameActive = false;
                gameResultDisplay.textContent = `Player ${currentPlayer} wins!`;
                gameResultDisplay.className = 'font-bold text-green-600';
                return;
            }
            
            if (!gameState.includes('')) {
                gameActive = false;
                gameResultDisplay.textContent = 'Game ended in a draw!';
                gameResultDisplay.className = 'font-bold text-yellow-600';
                return;
            }
            
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            currentPlayerDisplay.textContent = currentPlayer;
        }

        function resetTicTacToe() {
            createTicTacToeBoard();
        }

        // Initialize Tic Tac Toe
        createTicTacToeBoard();

        // ======================================
        // Memory Game Implementation
        // ======================================
        const memoryGameBoard = document.getElementById('memoryGameBoard');
        const pairsFoundDisplay = document.getElementById('pairsFound');
        const attemptsDisplay = document.getElementById('attempts');
        let memoryCards = [];
        let hasFlippedCard = false;
        let lockBoard = false;
        let firstCard, secondCard;
        let pairsFound = 0;
        let attempts = 0;
        const memorySymbols = ['üòÄ', 'ü§™', 'üòé', 'ü§©', 'ü•≥', 'ü§ì', 'üòç', 'ü•∂'];

        function startMemoryGame() {
            pairsFound = 0;
            attempts = 0;
            pairsFoundDisplay.textContent = pairsFound;
            attemptsDisplay.textContent = attempts;
            
            createMemoryCards();
        }

        function createMemoryCards() {
            // Create pairs of cards
            let cards = [...memorySymbols, ...memorySymbols];
            
            // Shuffle cards
            cards.sort(() => Math.random() - 0.5);
            
            memoryGameBoard.innerHTML = '';
            memoryCards = [];
            
            cards.forEach((symbol, index) => {
                const card = document.createElement('div');
                card.className = 'memory-card cursor-pointer';
                card.dataset.symbol = symbol;
                card.dataset.index = index;
                
                const inner = document.createElement('div');
                inner.className = 'memory-card-inner';
                
                const back = document.createElement('div');
                back.className = 'memory-card-back';
                back.textContent = '?';
                
                const front = document.createElement('div');
                front.className = 'memory-card-front';
                front.textContent = symbol;
                
                inner.appendChild(back);
                inner.appendChild(front);
                card.appendChild(inner);
                
                card.addEventListener('click', flipMemoryCard);
                memoryGameBoard.appendChild(card);
                memoryCards.push(card);
            });
        }

        function flipMemoryCard() {
            if (lockBoard) return;
            if (this === firstCard) return;
            
            this.classList.add('flipped');
            
            if (!hasFlippedCard) {
                hasFlippedCard = true;
                firstCard = this;
                return;
            }
            
            secondCard = this;
            lockBoard = true;
            attempts++;
            attemptsDisplay.textContent = attempts;
            
            checkForMatch();
        }

        function checkForMatch() {
            const isMatch = firstCard.dataset.symbol === secondCard.dataset.symbol;
            
            if (isMatch) {
                disableCards();
                pairsFound++;
                pairsFoundDisplay.textContent = pairsFound;
                
                if (pairsFound === memorySymbols.length) {
                    setTimeout(() => {
                        alert(`Congratulations! You won in ${attempts} attempts!`);
                    }, 500);
                }
            } else {
                unflipCards();
            }
        }

        function disableCards() {
            firstCard.removeEventListener('click', flipMemoryCard);
            secondCard.removeEventListener('click', flipMemoryCard);
            
            resetBoard();
        }

        function unflipCards() {
            setTimeout(() => {
                firstCard.classList.remove('flipped');
                secondCard.classList.remove('flipped');
                
                resetBoard();
            }, 1000);
        }

        function resetBoard() {
            [hasFlippedCard, lockBoard] = [false, false];
            [firstCard, secondCard] = [null, null];
        }

        // Initialize memory game
        startMemoryGame();

        // ======================================
        // Hangman Game Implementation
        // ======================================
        const hangmanCanvas = document.getElementById('hangmanCanvas');
        const hangmanCtx = hangmanCanvas.getContext('2d');
        const wordDisplay = document.getElementById('wordDisplay');
        const keyboard = document.getElementById('keyboard');
        const hangmanLivesDisplay = document.getElementById('hangmanLives');
        const categoryDisplay = document.getElementById('category');
        let hangmanLives = 6;
        let currentCategory = 'Animals';
        let currentWord = '';
        let guessedLetters = [];
        const wordsByCategory = {
            'Animals': ['elephant', 'giraffe', 'kangaroo', 'penguin', 'rhinoceros'],
            'Countries': ['argentina', 'brazil', 'canada', 'denmark', 'egypt'],
            'Fruits': ['apple', 'banana', 'cherry', 'dragonfruit', 'elderberry']
        };

        function startHangmanGame() {
            hangmanLives = 6;
            guessedLetters = [];
            hangmanLivesDisplay.textContent = hangmanLives;
            categoryDisplay.textContent = currentCategory;
            
            // Select random word from current category
            currentWord = wordsByCategory[currentCategory][Math.floor(Math.random() * wordsByCategory[currentCategory].length)];
            
            drawHangman();
            updateWordDisplay();
            createKeyboard();
        }

        function changeHangmanCategory() {
            const categories = Object.keys(wordsByCategory);
            const currentIndex = categories.indexOf(currentCategory);
            const nextIndex = (currentIndex + 1) % categories.length;
            currentCategory = categories[nextIndex];
            startHangmanGame();
        }

        function updateWordDisplay() {
            const displayWord = currentWord.split('').map(letter => 
                guessedLetters.includes(letter) ? letter : '_'
            ).join(' ');
            
            wordDisplay.innerHTML = '';
            wordDisplay.textContent = displayWord;
            
            // Check if player won
            if (!displayWord.includes('_')) {
                setTimeout(() => alert('Congratulations! You won!'), 100);
            }
        }

        function createKeyboard() {
            keyboard.innerHTML = '';
            
            const letters = 'abcdefghijklmnopqrstuvwxyz'.split('');
            
            letters.forEach(letter => {
                const button = document.createElement('button');
                button.textContent = letter;
                button.className = 'px-3 py-2 bg-indigo-100 text-indigo-800 rounded hover:bg-indigo-200 transition';
                
                if (guessedLetters.includes(letter)) {
                    button.disabled = true;
                    button.classList.add('opacity-50');
                    
                    if (currentWord.includes(letter)) {
                        button.classList.add('bg-green-100', 'text-green-800');
                    } else {
                        button.classList.add('bg-red-100', 'text-red-800');
                    }
                }
                
                button.addEventListener('click', () => guessLetter(letter));
                keyboard.appendChild(button);
            });
        }

        function guessLetter(letter) {
            if (guessedLetters.includes(letter)) return;
            
            guessedLetters.push(letter);
            
            if (!currentWord.includes(letter)) {
                hangmanLives--;
                hangmanLivesDisplay.textContent = hangmanLives;
                drawHangman();
                
                if (hangmanLives === 0) {
                    setTimeout(() => alert(`Game Over! The word was: ${currentWord}`), 100);
                }
            }
            
            updateWordDisplay();
            createKeyboard();
        }

        function drawHangman() {
            hangmanCtx.clearRect(0, 0, hangmanCanvas.width, hangmanCanvas.height);
            
            // Draw stick figure based on remaining lives
            if (hangmanLives < 6) {
                // Base
                hangmanCtx.beginPath();
                hangmanCtx.moveTo(10, 190);
                hangmanCtx.lineTo(50, 190);
                hangmanCtx.strokeStyle = '#000';
                hangmanCtx.lineWidth = 2;
                hangmanCtx.stroke();
            }
            
            if (hangmanLives < 5) {
                // Pole
                hangmanCtx.beginPath();
                hangmanCtx.moveTo(30, 190);
                hangmanCtx.lineTo(30, 10);
                hangmanCtx.stroke();
            }
            
            if (hangmanLives < 4) {
                // Top beam
                hangmanCtx.beginPath();
                hangmanCtx.moveTo(30, 10);
                hangmanCtx.lineTo(100, 10);
                hangmanCtx.stroke();
            }
            
            if (hangmanLives < 3) {
                // Rope
                hangmanCtx.beginPath();
                hangmanCtx.moveTo(100, 10);
                hangmanCtx.lineTo(100, 40);
                hangmanCtx.stroke();
            }
            
            if (hangmanLives < 2) {
                // Head
                hangmanCtx.beginPath();
                hangmanCtx.arc(100, 60, 20, 0, Math.PI * 2);
                hangmanCtx.stroke();
            }
            
            if (hangmanLives < 1) {
                // Body
                hangmanCtx.beginPath();
                hangmanCtx.moveTo(100, 80);
                hangmanCtx.lineTo(100, 140);
                hangmanCtx.stroke();
                
                // Arms
                hangmanCtx.beginPath();
                hangmanCtx.moveTo(100, 100);
                hangmanCtx.lineTo(70, 120);
                hangmanCtx.moveTo(100, 100);
                hangmanCtx.lineTo(130, 120);
                hangmanCtx.stroke();
                
                // Legs
                hangmanCtx.beginPath();
                hangmanCtx.moveTo(100, 140);
                hangmanCtx.lineTo(70, 160);
                hangmanCtx.moveTo(100, 140);
                hangmanCtx.lineTo(130, 160);
                hangmanCtx.stroke();
                
                // Face
                hangmanCtx.beginPath();
                hangmanCtx.arc(95, 55, 2, 0, Math.PI * 2); // Left eye
                hangmanCtx.arc(105, 55, 2, 0, Math.PI * 2); // Right eye
                hangmanCtx.stroke();
                
                hangmanCtx.beginPath();
                hangmanCtx.arc(100, 65, 5, 0, Math.PI); // Sad mouth
                hangmanCtx.stroke();
            }
        }

        // Initialize hangman game
        startHangmanGame();
    </script>
</body>
</html>